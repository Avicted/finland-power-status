/* tslint:disable */
/* eslint-disable */
/**
 * avoindata-api
 * API for Fingrid Open Data
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  TimeseriesDataResponse,
  ValidateError,
} from '../models/index';
import {
    TimeseriesDataResponseFromJSON,
    TimeseriesDataResponseToJSON,
    ValidateErrorFromJSON,
    ValidateErrorToJSON,
} from '../models/index';

export interface GetMultipleTimeseriesDataRequest {
    datasets: string;
    startTime?: Date;
    endTime?: Date;
    format?: GetMultipleTimeseriesDataFormatEnum;
    oneRowPerTimePeriod?: boolean;
    page?: number;
    pageSize?: number;
    locale?: GetMultipleTimeseriesDataLocaleEnum;
    sortBy?: GetMultipleTimeseriesDataSortByEnum;
    sortOrder?: GetMultipleTimeseriesDataSortOrderEnum;
}

/**
 * 
 */
export class DataApi extends runtime.BaseAPI {

    /**
     * Get data for multiple datasets. Returns empty array if no data is found. If only part of requested datasets have data in generel or for requested timespan, those data are returned.
     * GetMultipleTimeseriesData
     */
    async getMultipleTimeseriesDataRaw(requestParameters: GetMultipleTimeseriesDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TimeseriesDataResponse>> {
        if (requestParameters['datasets'] == null) {
            throw new runtime.RequiredError(
                'datasets',
                'Required parameter "datasets" was null or undefined when calling getMultipleTimeseriesData().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['datasets'] != null) {
            queryParameters['datasets'] = requestParameters['datasets'];
        }

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = (requestParameters['startTime'] as any).toISOString();
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = (requestParameters['endTime'] as any).toISOString();
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['oneRowPerTimePeriod'] != null) {
            queryParameters['oneRowPerTimePeriod'] = requestParameters['oneRowPerTimePeriod'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['locale'] != null) {
            queryParameters['locale'] = requestParameters['locale'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sortBy'] = requestParameters['sortBy'];
        }

        if (requestParameters['sortOrder'] != null) {
            queryParameters['sortOrder'] = requestParameters['sortOrder'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // apiKeyQuery authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // apiKeyHeader authentication
        }

        const response = await this.request({
            path: `/data`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TimeseriesDataResponseFromJSON(jsonValue));
    }

    /**
     * Get data for multiple datasets. Returns empty array if no data is found. If only part of requested datasets have data in generel or for requested timespan, those data are returned.
     * GetMultipleTimeseriesData
     */
    async getMultipleTimeseriesData(requestParameters: GetMultipleTimeseriesDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TimeseriesDataResponse> {
        const response = await this.getMultipleTimeseriesDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetMultipleTimeseriesDataFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Xml: 'xml'
} as const;
export type GetMultipleTimeseriesDataFormatEnum = typeof GetMultipleTimeseriesDataFormatEnum[keyof typeof GetMultipleTimeseriesDataFormatEnum];
/**
 * @export
 */
export const GetMultipleTimeseriesDataLocaleEnum = {
    En: 'en',
    Fi: 'fi'
} as const;
export type GetMultipleTimeseriesDataLocaleEnum = typeof GetMultipleTimeseriesDataLocaleEnum[keyof typeof GetMultipleTimeseriesDataLocaleEnum];
/**
 * @export
 */
export const GetMultipleTimeseriesDataSortByEnum = {
    StartTime: 'startTime',
    EndTime: 'endTime'
} as const;
export type GetMultipleTimeseriesDataSortByEnum = typeof GetMultipleTimeseriesDataSortByEnum[keyof typeof GetMultipleTimeseriesDataSortByEnum];
/**
 * @export
 */
export const GetMultipleTimeseriesDataSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetMultipleTimeseriesDataSortOrderEnum = typeof GetMultipleTimeseriesDataSortOrderEnum[keyof typeof GetMultipleTimeseriesDataSortOrderEnum];
